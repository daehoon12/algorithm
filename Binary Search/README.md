# Divide & Couquer 

1) Divide (분할) :  해결할 문제를 여러 개의 작은 부분으로 나눔
2) Conquer (정복) : 나눈 작은 문제를 각각 해결
3) Combine (통합) : (필요하다면) 해결된 해답을 모음

 분할 정복 알고리즘을 이용해 거듭 제곱을 연산하면 O(N)의 시간 복잡도를 O(logN)으로 줄일 수 있다.

- 분할 정복을 이용힌 Sort O(NlogN)

※ 사용하는 자료 구조 
      1. 배열 : Divide / Conquer 과정에서 빈번한 자료의 비교 연산과 이동 연산 발생으로 비효율적
      2. 연결 리스트 : 배열 사용 시 단점 극복으로 효과적인 구현 가능
  
1. Merge Sort (병합 정렬)
   1) Divide : 전체 자료 집합을 최소 부분집합이 될 때까지 분할 작업을 진행한다.
   2) Conquer : 함수를 재귀적으로 호출해 2개의 부분집합을 정렬 
   3) Combine :  모든 부분집합이 1개로 병합 될 때까지 반복.
    
2. Quick Sort (퀵 정렬) : 분할 시 피벗을 중심으로 작은 것은 왼쪽, 큰 것은 오른쪽에 위치, 매 분할 과정에서 어느 정렬이 이루어지므로 Combine 작업이 필요 없다.
    1) Divide : 피벗을 생성하고 그 기준으로 리스트를 비등균 분할
    2) Conquer : 함수를 재귀적으로 호출해 하나의 집합으로 만듬 

   2.1. 파티션 알고리즘
     - Hoare - Partion 알고리즘  : 피벗보다 큰 값은 피벗의 오른쪽, 작은 값은 왼쪽에 위치 시키고 피벗을 두 집합 가운데에 위치 시킴
     - Lomuto - Partion 알고리즘 : 

   ※ 퀵 소트는 피벗이 자료구조 안의 값이 최소값 or 최대값일 때 O(n^2)의 시간복잡도에 가까워짐
     -> ex) 1 2 3 4 5 6 7 8 9 에서 피벗을 1로 선택하면 모든 데이터가 1보다 크므로 제일 끝에 있는 인덱스가 1의 위치까지 오면서 종료
              이 과정을 9번 반복 -> O(n^2)

- Binary Search : 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    (단 자료구조의 값은 정렬되어 있는 상태여야 한다.)
      1) Divide : 자료의 가운데 값(mid)을 고름.
      2) Conquer : mid 값이 찾으려는 값보다 크거나 작을 때, 시작 값(low)을 늘리거나 끝 값(high)를 줄이면서 값을 찾아 나간다.             
